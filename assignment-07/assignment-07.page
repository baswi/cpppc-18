---
format: Markdown
title: Assignment 7
categories: cpppc, teaching
...

**C++ Programming Course, Summer Term 2018**

> "Because I'm hard, you will not like me. \
> \ But the more you hate me, the more you will learn." \
> -- [Gunnery Sgt. Hartman](https://www.youtube.com/watch?v=3j3_iPskjxk)


# 7-1 Fixing the Google Tech Interview

Google has an official YouTube channel for recruiting software engineers
where they published this video of a staged tech interview, presumably to
demonstrate what Google would expect from candidates:

[https://www.youtube.com/watch?v=XKu_SEDAykw]()

Regrettably, comments have been disabled for this video.

Wipe the floor with the C++ implementation that is showcased as an acceptable
solution (at [15:29](https://youtu.be/XKu_SEDAykw?t=15m29s) in the video):

1. Shake your head in disbelief and disgust
2. Provide an improved variant of the `HasPairWithSum` function \
   (feel free to also improve its name)
3. Provide use cases to explain in which numerous ways the original
   implementation is lacking and why your improvements are essential
4. Become aware that you got pretty good at C++



# 7-2 Pass the Resource to the Left-hand Side

## 7-2-1 Move Operator

## 7-2-2 Move Criminal


# 7-3 Act Like You Got a Pair

The utility template `std::pair<A,B>` is a useful companion due to its utmost
simplicity and predictability: just a struct of two values `first` and `second`
with independent types.

Experiment with minimal examples to answer the following questions:

- How do comparison operators of `pair<A,B>` depend on types `A` and `B`?
- How can we specify comparison of `pair<A0,B0>` and `pair<A1,B1>`? 
- What is the benefit of `std::get` over `pair.first` / `pair.second` \
  (use compiler explorer)
- Why don't we just always use `std::get`?

The most traditional ways to represent a range are:
- a pair of iterators
- a pair of an iterator and an offset

Implement as minimal proof-of-concepts:

- Specialize `std::make_pair` for iterator and offset, that is: \
  Define a variant of `std::make_pair(T, int)` matching parameter types `T` that
  provide a type definition `iterator_category`
- Define `std::begin(std::pair<A,B> p)` and `std::end(std::pair<A,B> p),
  returning \
  `std::get<0>(p)` and \
  `std::advance(std::get<0>(p), std::get<1>(p)` respectively.

Use compiler explorer to check that your specializations have no overhead.




# 7-4 The runtimes / they are a-changin'

## 7-4-0 Prerequisites 

Clone *Celero* from [https://github.com/DigitalInBlue/Celero]() and experiment with
the examples in the distribution.

