---
format: Markdown
title: Session 6 Summary
...

# Idiom: Curiously Recurring Template Pattern

[Article on FluentCpp](https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/)

# Move Semantics Continued


## Universal Reference

In [the last session](/session-05/session-05), we learned declarations of `rvalue` references (actually: `xvalue`):

~~~c++
void wrapper(Foo && foo) {
   func(foo);
}
~~~

To tell whether you need `std::move` or not, just remember that it is equivalent to `static_cast<Foo &&>(foo)`. In this example, `foo` already is an `rvalue` reference so there is no need to `std::move`. It would not hurt but just have no effect.

Now I need you to relax and remember that high blood pressure leads to serious disease, so try not to get upset.

In the following example, parameters `rval_ref` and `univ_ref` do not have the same type category:

~~~c++
void wrapper_rval(Foo && rval_ref);

template <class T>
void wrapper_univ(T && univ_ref);
~~~


## Perfect Forwarding



## Move-only Types

Types that only provide move construction and move assignment and forbid any
other instantiation method are called *move-only types*.
In effect, a move-only object, and in effect its resources, cannot be cloned
to another owner or shared between objects.


# Smart Pointers and Move Semantics

## std::unique_ptr

[Reference to std::unique_ptr](http://en.cppreference.com/w/cpp/memory/unique_ptr)

`std::unique_ptr` maintains exclusive ownership semantics.
A non-null `std::unique_ptr` always owns what it points to. Consequently, copying it
must be forbidden as all owners would assume exclusive access to the encapsulated
object.
It is therefore a move-only type: moving a `std::unique_ptr` transfers ownership
from the source pointer to the destination pointer.

## std::shared_ptr

# Views and Ranges

Shameless plug:

- [Tobias Fuchs - "The Point of Views: Multidimensional Ranges for HPC"](https://www.youtube.com/watch?v=JsGsgRnbIpU)


# Idioms - Patterns for the Sophisticated

Much like design patterns, idioms are common techniques that have been proven
beneficial for common situations.
We already discussed several idioms along the way, but there are just way too
many to cover all of them in a single semester.

Some idioms we encountered so far: 

- Tag dispatching
- Iterator pairs
- [Metafunctions](http://www.artima.com/cppsource/metafunctions.html), Type Generators
  and [Type Selection](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Selection)
- [RAII](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Resource_Acquisition_Is_Initialization), of course
- Just recently, [Computational Constructors](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Computational_Constructor)

... and many more.

[Others](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Generic_Container_Idioms), 
mostly those related to allocation, have been intentionally skipped.

The following related idioms have not been discussed so far and deserve an explicit
mention.


## Policies

## Curiously Recurring Pattern Template


